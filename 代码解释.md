# 代码解释

这个文件会简单的解释代码。

tiny-LightGbm是cpython混合编程，目前c++提供的接口主要是以下四个：

[1.LGBM_DatasetCreateFromMat](#jupm1)

[2.LGBM_BoosterCreate](#jump2)

[3.LGBM_BoosterUpdateOneIter](#jump3)

[4.LGBM_BoosterPredictForMat](#jump4)



## <span id="jump1">LGBM_DatasetCreateFromMat</span>

![1576224418157](pic\pic1.png)

以上是DataSet类的架构。

dataloader是辅助类，构造dataset。

![1576224644356](pic\1576224644356.png)

这里并没有直接放入所有数据，0周围的数据并没有放入。

针对每一个feature构造一个BinMapper。每一个BinMapper里维护一个bin_upper_bound_，这里有个default_bin。

![1576224736996](pic\1576224736996.png)

default_bin是放在value_to_bin（0），即对于不同的feature，其取值不一样。

有了BinMapper之后，构造featuregroup。featuregroup里面维护bin_mappers_，里面有多个bin_mapper，

因为featuregroup里面有多个feature。EFB这里计算feature的范围也不是数值大小，而是bin的数量。

例如feature1：bin（0-10），feature2：bin（10-20）

这里有个细节操作，如果default_bin是在0这个位置，那么要-=1。

![1576224848068](pic\1576224848068.png)

构造了featuregroup之后，需要投入数据。feature_group的另外一个类，DenseBin。

这个类维护一个data_，data_[i] = j。j代表bin的index。

投入数据的时候，并不是所有的数据都进去，因为默认的bin就是0。

注意的是，bin0是需要特殊处理的，最初所有数据都放在bin0里面，随后将数据分发出去

（这里的data_的bin的个数，是比bin_upper_bound_多一个，bin0）

![1576224912980](pic\1576224912980.png)

以上的操作，根据我的理解是对于不同的feature可以得到相同的结果。

比如feature1，其值有正有负，那么default_bin就到了非0的位置，添加数据的bin可以为1。（bin=0，bin_offsets = 1，那么bin = 1）

又如feature2，其值只有正，那么default_bin就是0的位置，添加的数据的bin也是1。（bin=1，bin_offsets =1,bin-=1 , 那么bin=1）

保持了一致。



## <span id="jump2">LGBM_BoosterCreate</span>



## <span id="jump3">LGBM_BoosterUpdateOneIter</span>



## <span id="jump4">LGBM_BoosterPredictForMat</span>

